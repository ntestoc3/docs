
Bug Hunter.

ethical hacker.

right and wrong.

打破默认的假设。假设输入合法，在规定的框架流程内进行工作。
软件的健壮性太复杂，很难处理所有情况。
可靠性的实现难度比较大。

一系列的漏洞是因为错误的假设。对现实的错误想象。

对新加、修改的内容格外注意，测试逻辑是否正确实现。
在出错的地方很容易再犯错。

注意发现使用同一个变量名id,有不同表示的地方，是否可以互换，或者是编码过。

* 按漏洞方式描述
  - 什么样的漏洞
  - 示例
  - 总结
    
  一些常见的犯错的模式，由于思考不周密、typo、所用工具、外部环境(不可控的生存环境，env)造成的漏洞。

  站在开发者的角度思考全局，程序运行环境、架构、与用户或其他程序的交互、代码细节,可以的话检查代码。

* Internet
  数据输入输出交流，单向、双向。

  数据，Data,对数据的解释。 Raw,Parser,Render.
  
* Open Redirect
  开放重定向，未检查重定向参数中的目的地，做了错误的假定。


  信任误用的问题

* HTTP Parameter Pollution
  HPP,对http头的错误信任。

  你能看到发送的数据和返回的结果，处理过程是黑盒。
  发送两个同样的参数，值不同，程序的处理结果也不一样，对services运行的软件环境及代码有依赖。
* Cross-Site Request Forgery
  第三方网站直接发送CSRF请求,没有保护的网站不对来源进行审核，执行了这个请求，并且使用了用户已经登录的的cookie.

  牢记http是无状态的，对于没一个请求，服务器端是无法分辨哪个用户的,所以要重新验证。

* HTML Injection
  对文本的错误解析，并使用输出。

* CRLF Injection
  没有对用户输入进行无害处理。
  
  特别是在HTTP头中,把用户输入带入HTTP头，没有正确处理换行，导致HTTP头可以重写。
  使用Unicode字符，U+560A,包含一个0A

  字符编码的重要性。

  分析数据的流动，输出的数据从哪里来，输入怎么影响它。

* Cross-Site Scripting
  Test everything，十分注意web程序接受的输入又显示出来的地方。

  对客户端代码验证的东西十分注意，因为开发者可能觉得客户端已经做过验证了，对输入数据做了错误的假定及信任。

  传递不合法的或坏的HTML可以测试可靠性，是否正确处理了？

  打破开发者所做的假定，假定数据格式正确，不会出错，可以信任,美好的幻想。

  不要因为一个网站的历史、功能、品牌等就假定没有漏洞，所有已知的网站都有未发现的bug。
  
* Template Injection
  模板引擎用于把表现(presentation)逻辑从应用逻辑中分离。

  SSTI(Server side template injections)

* SQL Injection
  SQLi

* Server Side Request Forgery
  SSRF 让服务端发送意外网络请求
  与CSRF类似，不过是发生在服务端

* HTTP头
  出现问题的地方：
  - HOST: 构造错误域名，服务器错误使用,绕过访问限制，通过Host判断是内部测试地址之类的。
  - X-Forwarded-For: Blind XSS(通过log),  伪造IP,绕过ip过滤，使用本地ip
  - Referer,User-Agent 都会出问题

    服务端对HTTP头的错误信任，假设错误。
  
   服务器发送的邮件特别注意。 
